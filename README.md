# Planat PWA
First need a request to access demo cors server at https://cors-anywhere.herokuapp.com/corsdemo

The web app can be accessed here: https://planat-3b625.firebaseapp.com/

To ensure the web app functions correctly, both the private and public keys must be provided.

PlanAt is a travel web application that allows users to find some of the recreation places that best suit their needs by providing some information at searching. 
During the development of PlanAt PWA, I was focusing on what PWA components and features contribute to improving the user experience of web applications. PWAs significantly improve the user experience of classic web applications mainly through offline usability, speed, and application-like appearance. At the development of each component and functionality, I paid attention to many UX aspects, that I haven’t detailed in this document. 

## 1.	UI Components

First Page: Home
  1. Header with the logo
  2. Banner with an image and a motto
  3. Search bar
  4. Categorized activities
  5. 2 Recommendations section
  5.1 Static cards: The application makes some recommendations for the users, displaying the most popular attractions
  5.2 Dynamic cards: This component is a carousel, where the recommendations are made from a specific category and a specific city.
    
Second page: Search results
  1. The same header but with a back button
  2. The same Search bar
  3. Activities 
  4. Search Results/Sight list
  5. Leaflet Map
    
Third page: Details
  1. Title
  2. Slider with the images
  3. Information: Address, Rating, Contact, Website, Opening hours
  4. Reviews
  5. Map
  6. Recommendations

## 2.	PWA UI components

   •	**Install Snackbar**
      
   If the application is not already installed, the snackbar will appear in the upper right corner of the screen, which will automatically disappear after 7 seconds.

   •	**Notification bar:OfflineMessage.jsx**
   
   When the user is offline and has cached data, the application is displayed as online but a notifying bar appears at the bottom of the screen

  •  **Push Notification Popup**
      
   To request permission, I created a separate pop-up window. The popup asking for user consent appears 2 minutes after the page is opened. If the user agrees to         receive notifications, a window will appear offered by the browser for the same purpose, in which he/she can confirm again, thus also "officially" subscribing to       our notifications. If the user does not enable notifications, these windows will no longer appear until he/she changes this in the settings.

## 3.	Planat PWA features


### 3.1.	Install like a native app
   
   __Implemented with: Material UI, PWACompat, manifest file__
   
   __Files where the code is: source/components/install.jsx, public/manifest.json__
   
   __Process description:__
   
   First, an install component was developed to notify the user that the app can be installed. This was done with the Material UI Snackbar component including the         installation message and Install button, as well as a little JavaScript code to handle the installation.
    
   If the application is not already installed, the snackbar will appear in the upper right corner of the screen, which will automatically disappear after 7 seconds.     As soon as the user installs the application, the installation snack bar will no longer appear, and the application will launch in a completely new, native             application-like window and the icon will appear on the user's home screen.
    
   Initially, a __manifest.json__ file was required to display the PlanAt application icon and display the installation window. For installing the application on         mobile devices, the mentioned manifest.json file is enough for Android operating system but needed some extra work to make it working on iOS too. Although the         installation command is still not available on iOS, the PWACompat library can easily generate the necessary tools for PWA support on iOS devices. In addition to       the previously added manifest.json file, PlanAt uses PWACompat to create home screen icons and appropriate meta tags for Safari. Since the icon generated by           PWACompat did not prove to be correct, I had to add my own as follows:
    
       <link rel = "apple-touch-icon" href = "planat_logo_mini_192.png" sizes = "192x192">
    
  Why is this a good solution?
  
  The "add to home screen" feature is an essential part of Progressive Web Applications to provide the same user experience as native ones. Also, I think this is the     best way to do this.


 
  ### 3.2. Fast and Offline working
  
  __Implemented with: Service worker + cache API__
  
  __Files where the code is: public/main.js, public/sw.js, src/components/OfflineMessage.jsx__
  
  __Process description:__
  
   First, I registered the service-worker in a __main.js__ file. Also created a __sw.js__ file where I first installed the service worker. The installation is the       right time to save the application shell, so the caching takes place here. During the activation phase, it checks to see if there is another cache file with the       same name and deletes it, this will prevent the accumulation of outdated data. Once the files have been cached, we can intercept requests for files from the           network and respond with the files from the cache. Here I used the “cache falling back to network” strategy: the request first hits the cache. If the asset is in       the cache, serve it from there, otherwise go to the network. When the user is offline and has cached data, the application is displayed as online but a notifying       bar appears at the bottom of the screen. If both solutions fail for some reason, an offline.html page will be displayed, covering all possibilities, and avoiding       the classic browser error message.
    
 Why is this a good solution?
 
In providing speed, caching helps because once a user has visited the site with a proper network connection, the next time the application loads much faster,        because some data is already loaded from the cache almost immediately. Additionally, the user can run the application offline. As a result, previously cached          content and an offline warning message are displayed. The user needs to have a positive experience even without a network connection. PlanAt is designed to perform      great even offline, as there is almost no difference in appearance between the two states.



  ### 3.3. Send push notifications

  __Implemented with: FCM JavaScript API, Push API, service worker__
  
  __Files where the code is: src/services/firebase.js , src/components/PushPermission.jsx, public/firebase-messaging-sw.js__
  
  __Process description:__
  
   First, I added the Firebase Cloud Messaging dependencies to React with the “npm install --save firebase” command. Then created a Firebase project for the               application. After that, I had to add the Firebase SDK, which contains 3 scripts. This is followed by the initialization and the Firebase project and the React         application are now connected. The code for this can be found at __src/services/firebase.js__

   In the second phase of the notification sending process, the first thing was to integrate the cloud messaging service by invoking the firebase messaging object. To     request permission, I created a separate pop-up window in addition to the pop-up window offered by the browser for the same purpose. The popup asking for user         consent appears 2 minutes after the page is opened. If the user agrees to receive notifications, a window will appear offered by the browser for the same purpose,     in which he/she can confirm again, thus also "officially" subscribing to our notifications. If the user does not enable notifications, these windows will no longer     appear until he/she changes this in the settings. The pop-up window is triggered by calling the getToken () method. If the user allows notifications to appear,         the app will contact Firebase Cloud Messaging and create a new subscription. The code for this part can be found at __src/components/PushPermission.jsx__

   To send and manage push notifications, a service worker file is needed: __public/firebase-messaging-sw.js__ that contains the Firebase SDK. In this file, the           service worker is registered wich is required for messaging. In addition, to receive and display the message, the sender ID of the message must be specified and       called the firebase.messaging() method mentioned above.

Why is this a good solution?

From my point of view, this is a good solution because it is a very simple, elegant and fast way to send push notifications through webservices.

